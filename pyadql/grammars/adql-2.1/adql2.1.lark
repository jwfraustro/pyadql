// Lark grammar for ADQL 2.1

// ============================ The Grammar's root symbol

query_specification: with_clause? query_expression

// ============================ Top level query parts

with_clause: "WITH"i with_query ("," with_query)*

with_query: identifier as "(" query_expression ")"

query_expression: select_query (set_operator set_query_expression)*

set_operator: ("EXCEPT"i | "INTERSECT"i | "UNION"i) _A ("ALL"i _A)?

set_query_expression: query_expression
    | "(" query_expression ")"

// Select clause

select_query: "SELECT"i (set_quantifier)? (set_limit)? select_list table_expression

set_quantifier: ("DISTINCT"i | "ALL"i) _A

set_limit: "TOP"i UNSIGNED_INTEGER

// ================================= Select lists and their items
select_list: "*" -> select_all
    | select_sublist ("," select_sublist)*

?select_sublist: table_name "." "*"
    | derived_column

?derived_column: value_expression as_clause?

// Table expressions (FROM clause: tables, join, etc.)

table_expression: from_clause (where_clause)? (group_by_clause)? (order_by_clause)? (offset_clause)?

from_clause: "FROM"i from_list

from_list: table_reference ("," table_reference)*

// joining correlation_specification and as_clause

as_clause: "AS"i? identifier

table_reference: joined_table
    | table_name (SPACE as_clause)?
    | subquery (SPACE  as_clause)?

// JOIN clauses and related elements

joined_table: qualified_join
    | sub_join

sub_join: "(" joined_table ")"

join_opener: sub_join
    | table_name as_clause?
    | subquery as_clause?

qualified_join: join_opener join_clause

subquery: "(" query_expression ")"

join_clause: join_method? join table_reference (join_specification)? ((sub_join | join_clause))*

join_type: ("INNER"i
    | (outer_join_type)? "OUTER"i) _A

outer_join_type: ("LEFT"i | "RIGHT"i | "FULL"i) _A

join_method: natural? (join_type)?

join_specification: join_condition
    | named_columns_join

join_condition: on search_condition

named_columns_join: "USING"i "(" identifier ("," identifier)* ")"

// WHERE clause

where_clause: "WHERE"i _A search_condition

search_condition: boolean_term ("OR"i _A boolean_term)*

?boolean_term: boolean_factor ("AND"i _A boolean_factor)*

?predicate: comparison_predicate
    | between_predicate
    | in_predicate
    | like_predicate
    | null_predicate
    | exists_predicate

?boolean_factor: not? boolean_primary

?boolean_primary: "(" search_condition ")"
    | predicate

null_predicate: column_reference "IS" not? ("TRUE"i | "FALSE"i | "UNKNOWN"i | "NULL"i)

comparison_predicate: value_expression comp_op value_expression

like_predicate: character_value_expression not? ("ILIKE"i | "LIKE"i) character_value_expression

comp_op: "=" -> equal
    | "<>" -> not_equal
    | "<" -> less_than
    | ">" -> greater_than
    | "<=" -> less_than_or_equal
    | ">=" -> greater_than_or_equal

between_predicate: value_expression not? between value_expression and value_expression

in_predicate: value_expression not? in in_predicate_value

in_predicate_value: identifier
    | "(" value_expression ("," value_expression)* ")"
    | "(" query_expression ")"

exists_predicate: not? "EXISTS"i subquery

order_by_clause: "ORDER"i "BY"i sort_specification_list

sort_specification_list: sort_specification ("," sort_specification)*

sort_specification: sort_key (ordering_specification)?

sort_key: identifier
    | UNSIGNED_INTEGER

ordering_specification: "ASC"i | "DESC"i

// HAVING clause depends on GROUP BY clause
group_by_clause: "GROUP"i "BY"i group_by_term_list (having_clause)?

group_by_term_list: identifier ("," identifier)*

having_clause: "HAVING"i ("(" search_condition ")"
    | search_condition)

offset_clause: "OFFSET"i UNSIGNED_INTEGER

// Identifiers (<schema>.<table>.<field>), numerical, geometrical, string expressions and functions

table_name: identifier ("." identifier)~0..2

// # we don't re-use table_name here since PEG uses greedy matching
// # and thus would parse x.a all as a table name.  Thus, for
// # column_reference we simply allow 1..4 identifiers.
column_reference: (identifier ".") ~ 0..3 identifier

?identifier: (regular_identifier | delimited_identifier)

?delimited_identifier: /"([^"]|\"\")*"/

?regular_identifier: ((keyword)~0 /[a-zA-Z]+[a-zA-Z0-9_]*/)

character_string_literal: (/[']/ (/['']/ | /[^']/)* /[']/ (SPACE+ SQL_COMMENT)*)+

fold_function: ("UPPER"i | "LOWER"i) "(" character_value_expression ")"

string_value_function: string_geometry_function
    | fold_function
    | user_defined_function

?character_primary: character_string_literal
    | string_value_function
    | value_expression_primary

concatenation: character_primary "||" character_value_expression

geometry_function: geometry_value_function
    | non_predicate_geometry_function
    | predicate_geometry_function
    | region
    | extract_coord_sys

bitwise_op: "&" | "|" | "^"

bitwise_expression: "~" numeric_value_expression
    | numeric_value_expression bitwise_op numeric_value_expression

string_value_expression: character_value_expression

?character_value_expression: concatenation
    | column_reference
    | character_primary

?geometry_value_function: box
    | centroid
    | circle
    | point
    | polygon
    | region
    | user_defined_function

coordinates: numeric_value_expression "," numeric_value_expression

box: "BOX"i "(" ( character_string_literal ",")? coordinates "," numeric_value_expression "," numeric_value_expression ")"

centroid: "CENTROID"i "(" geometry_value_expression ")"

circle: "CIRCLE"i "(" string_value_expression "," coordinates "," numeric_value_expression ")"

polygon: "POLYGON"i "(" string_value_expression "," coordinates "," coordinates ("," coordinates)* ")"

non_predicate_geometry_function: area
    | coord1
    | coord2
    | distance

area: "AREA"i "(" geometry_value_expression ")"

coord1: "COORD1"i "(" coord_value ")"

coord2: "COORD2"i "(" coord_value ")"

coord_value: point
    | column_reference

distance: "DISTANCE"i "(" coord_value "," coord_value ")"

predicate_geometry_function: contains
    | intersects

contains: "CONTAINS"i "(" geometry_value_expression "," geometry_value_expression ")"

intersects: "INTERSECTS"i "(" geometry_value_expression "," geometry_value_expression ")"

region: "REGION"i "(" string_value_expression ")"

extract_coord_sys: "COORDSYS"i "(" geometry_value_expression ")"

string_geometry_function: extract_coord_sys
    | user_defined_function

math_function: (onetwo_param_math "(" numeric_value_expression ("," SIGNED_INTEGER)? ")")
    | (two_param_math "(" numeric_value_expression "," numeric_value_expression ")" )
    | (one_param_math "(" numeric_value_expression ")")
    | rand_function
    | (no_param_math "(" ")")

trig_function: (two_param_trig "(" numeric_value_expression "," numeric_value_expression ")")
    | (one_param_trig "(" numeric_value_expression ")")

// No Params
no_param_math: "PI"i

// One Param
one_param_trig: "ACOS"i
    | "ASIN"i
    | "ATAN"i
    | "COS"i
    | "COT"i
    | "SIN"i
    | "TAN"i

one_param_math: "ABS"i
    | "CEILING"i
    | "DEGREES"i
    | "EXP"i
    | "FLOOR"i
    | "LOG10"i
    | "LOG"i
    | "RADIANS"i
    | "SQRT"i

// Two Params
two_param_math: "MOD"i | "POWER"i

two_param_trig: "ATAN2"i

onetwo_param_math: "ROUND"i | "TRUNCATE"i

rand_function: "RAND"i "(" (numeric_value_expression)? ")"

string_function: string_func_name "(" value_expression ")"

string_func_name: "LOWER"i

set_function_specification: "COUNT"i "(" ("*" | (set_quantifier)? identifier) ")"
    | general_set_function

set_function_type: "AVG"i | "MAX"i | "MIN"i | "SUM"i

general_set_function: set_function_type "(" set_quantifier? numeric_value_expression ")"

point: "POINT"i "(" ( string_value_expression | "NULL"i) "," coordinates ")"

numeric_value_expression: term (("+" | "-") numeric_value_expression)*

term: factor (("*" | "/") term)*

factor: ("-" | "+")? numeric_primary

numeric_value_function: math_function
    | trig_function
    | numeric_geometry_function
    | user_defined_function

numeric_geometry_function: predicate_geometry_function
    | non_predicate_geometry_function

udf_name: udf_prefix regular_identifier

user_defined_function: udf_name "(" (value_expression ("," value_expression)*)? ")"

// We need to seriously re-write value_expression because PEG
// doesn't have an actual longest-match operator.  Thus, we
// cannot decide on the type of the first operand.
// TODO: see how much this overproduces wrt the original grammar:
// (e.g., is '5'+4+3 ok by the BNF?  PG accepts that, btw)

?value_expression_first_operand: user_defined_function
	| column_reference
	| string_expression_operand
	| numeric_expression_operand

?value_expression: (value_expression_first_operand ( string_expression_rest | numeric_expression_rest)? | geometry_value_expression)

// TODO: value_expression_primary (as in the BNF) is unnecessarily wide
// here ("CENTROID(3)")
?geometry_value_expression: value_expression_primary
    | geometry_value_function

?value_expression_primary: unsigned_literal
    | column_reference
    | set_function_specification
    | "(" value_expression ")"

string_expression: string_expression_operand (string_expression_rest)*

?string_expression_operand: character_value_expression

string_expression_rest: "||" string_expression_operand

numeric_expression: numeric_expression_operand (numeric_expression_rest)*

numeric_expression_operand: numeric_value_expression

numeric_expression_rest: ("+" | "-" | "*" | "/") numeric_expression_operand

approximate_numeric_literal: exact_numeric_literal "E"i SIGNED_INTEGER

exact_numeric_literal: (UNSIGNED_INTEGER ".")* UNSIGNED_INTEGER

// TODO: We should take out character_string_literal here, MD thinks --
// what sort of use case did people have in mind here?
// "POINT('ICRS',X,'SY')"

?unsigned_literal: unsigned_numeric_literal
    | character_string_literal

?unsigned_numeric_literal: approximate_numeric_literal
    | exact_numeric_literal

numeric_primary: value_expression_primary
    | numeric_value_function

unsigned_hexadecimal: "0x"i HEXDIGIT+

// Reserved words

?as: "AS"i _A

?on: "ON"i _A

?in: "IN"i _A

?join: "JOIN"i _A

?natural: "NATURAL"i _A

?between: "BETWEEN"i _A

?and: "AND"i _A

?or: "OR"i _A

?not: "NOT"i _A

?where: "WHERE"i _A

?keyword: adql_reserved_word | sql_reserved_word

?adql_reserved_word: ("ABS"i
    | "ACOS"i
    | "AREA"i
    | "ASIN"i
    | "ATAN2"i
    | "ATAN"i
    | "BIT_AND"i
    | "BIT_NOT"i
    | "BIT_OR"i
    | "BIT_XOR"i
    | "BOX"i
    | "CEILING"i
    | "CENTROID"i
    | "CIRCLE"i
    | "CONTAINS"i
    | "COORD1"i
    | "COORD2"i
    | "COORDSYS"i
    | "COS"i
    | "DEGREES"i
    | "DISTANCE"i
    | "EXP"i
    | "FLOOR"i
    | "ILIKE"i
    | "INTERSECTS"i
    | "IN_UNIT"i
    | "LOG10"i
    | "LOG"i
    | "MOD"i
    | "PI"i
    | "POINT"i
    | "POLYGON"i
    | "POWER"i
    | "RADIANS"i
    | "REGION"i
    | "RAND"i
    | "ROUND"i
    | "SIN"i
    | "SQRT"i
    | "TOP"i
    | "TAN"i
    | "TRUNCATE"i )

?sql_reserved_word: ("ABSOLUTE"i
| "ACTION"i
| "ADD"i
| "ALLOCATE"i
| "ALL"i
| "ALTER"i
| and
| "ANY"i
| "ARE"i
| as
| "ASC"i
| "ASSERTION"i
| "AT"i
| "AUTHORISATION"i
| "AVG"i
| "BEGIN"i
| between
| "BIT_LENGTH"i
| "BIT"i
| "BOTH"i
| "BY"i
| "CASCADE"i
| "CASCADED"i
| "CASE"i
| "CAST"i
| "CATALOG"i
| "CHARACTER"i
| "CHAR_LENGTH"i
| "CHAR"i
| "CHARACTER_LENGTH"i
| "CHECK"i
| "CLOSE"i
| "COALESCE"i
| "COLLATE"i
| "COLLATION"i
| "COLUMN"i
| "COMMIT"i
| "CONNECT"i
| "CONNECTION"i
| "CONSTRAINT"i
| "CONSTRAINTS"i
| "CONTINUE"i
| "CONVERT"i
| "CORRESPONDING"i
| "COUNT"i
| "CREATE"i
| "CROSS"i
| "CURRENT_DATE"i
| "CURRENT_TIME"i
| "CURRENT_TIMESTAMP"i
| "CURRENT_USER"i
| "CURRENT"i
| "CURSOR"i
| "DATE"i
| "DAY"i
| "DEALLOCATE"i
| "DECIMAL"i
| "DECLARE"i
| "DEFAULT"i
| "DEFERRABLE"i
| "DEFERRED"i
| "DELETE"i
| "DESCRIBE"i
| "DESCRIPTOR"i
| "DESC"i
| "DIAGNOSTICS"i
| "DISCONNECT"i
| "DISTINCT"i
| "DOMAIN"i
| "DOUBLE"i
| "DROP"i
| "ELSE"i
| "'ENDEXEC"i
| "END"i
| "ESCAPE"i
| "EXCEPT"i
| "EXCEPTION"i
| "EXECUTE"i
| "EXEC"i
| "EXISTS"i
| "EXTERNAL"i
| "EXTRACT"i
| "FALSE"i
| "FETCH"i
| "FIRST"i
| "FLOAT"i
| "FOR"i
| "FOREIGN"i
| "FOUND"i
| "FROM"i
| "FULL"i
| "GET"i
| "GLOBAL"i
| "GOTO"i
| "GO"i
| "GRANT"i
| "GROUP"i
| "HAVING"i
| "HOUR"i
| "IDENTITY"i
| "IMMEDIATE"i
| "INDICATOR"i
| "INITIALLY"i
| "INNER"i
| "INPUT"i
| "INSENSITIVE"i
| "INSERT"i
| "INTEGER"i
| "INTERSECT"i
| "INTERVAL"i
| "INTO"i
| "INT"i
| "IN"i
| "IS"i
| "ISOLATION"i
| join
| "KEY"i
| "LANGUAGE"i
| "LAST"i
| "LEADING"i
| "LEFT"i
| "LEVEL"i
| "LIKE"i
| "ILIKE"i
| "LOCAL"i
| "LOWER"i
| "MATCH"i
| "MAX"i
| "MIN"i
| "MINUTE"i
| "MODULE"i
| "MONTH"i
| "NAMES"i
| "NATIONAL"i
| natural
| "NCHAR"i
| "NEXT"i
| "NO"i
| not
| "NULL"i
| "NULLIF"i
| "NUMERIC"i
| "OCTET_LENGTH"i
| "OFFSET"i
| "OF"i
| on
| "ONLY"i
| "OPEN"i
| "OPTION"i
| or
| "ORDER"i
| "OUTER"i
| "OUTPUT"i
| "OVERLAPS"i
| "PAD"i
| "PARTIAL"i
| "POSITION"i
| "PRECISION"i
| "PREPARE"i
| "PRESERVE"i
| "PRIMARY"i
| "PRIOR"i
| "PRIVILEGES"i
| "PROCEDURE"i
| "PUBLIC"i
| "READ"i
| "REAL"i
| "REFERENCES"i
| "RELATIVE"i
| "RESTRICT"i
| "REVOKE"i
| "RIGHT"i
| "ROLLBACK"i
| "ROWS"i
| "SCHEMA"i
| "SCROLL"i
| "SECOND"i
| "SELECT"i
| "SECTION"i
| "SESSION_USER"i
| "SET"i
| "SIZE"i
| "SMALLINT"i
| "SOME"i
| "SPACE"i
| "SQL"i
| "SQLCODE"i
| "SQLERROR"i
| "SQLSTATE"i
| "SUBSTRING"i
| "SUM"i
| "SYSTEM_USER"i
| "TABLE"i
| "TEMPORARY"i
| "THEN"i
| "TIMESTAMP"i
| "TIMEZONE_HOUR"i
| "TIMEZONE_MINUTE"i
| "TIME"i
| "TO"i
| "TRAILING"i
| "TRANSACTION"i
| "TRANSLATE"i
| "TRANSLATION"i
| "TRIM"i
| "TRUE"i
| "UNION"i
| "UNIQUE"i
| "UNKNOWN"i
| "UPDATE"i
| "UPPER"i
| "USAGE"i
| "USER"i
| "USING"i
| "VALUES"i
| "VALUE"i
| "VARCHAR"i
| "VARYING"i
| "VIEW"i
| "WHENEVER"i
| "WHEN"i
| where
| "WITH"i
| "WORK"i
| "WRITE"i
| "YEAR"i
| "ZONE"i )

_A: /[^A-Z0-9_]/

udf_prefix: "ivo_"i

%import common.LETTER
%import common.DIGIT
%import common.LCASE_LETTER -> SIMPLE_LATIN_LOWER_CASE_LETTER
%import common.UCASE_LETTER -> SIMPLE_LATIN_UPPER_CASE_LETTER
%import common.INT -> UNSIGNED_INTEGER
%import common.SIGNED_INT -> SIGNED_INTEGER
%import common.NEWLINE
%import common.HEXDIGIT
%import common.SQL_COMMENT
%import common.WS_INLINE -> SPACE
%import common.NEWLINE

%ignore SPACE