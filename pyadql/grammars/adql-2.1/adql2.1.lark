// Lark grammar for ADQL 2.1

// ============================ The Grammar's root symbol

query_specification: with_clause? query_expression

// ============================ Top level query parts

with_clause: "WITH" with_query ("," with_query)*

with_query: identifier as "(" query_expression ")"

query_expression: select_query (set_operator set_query_expression)*

set_operator: ("EXCEPT" | "INTERSECT" | "UNION") _a ("ALL" _a)?

set_query_expression: query_expression
    | "(" query_expression ")"

// Select clause

select_query: "SELECT" (set_quantifier)? (set_limit)? select_list table_expression

set_quantifier: ("DISTINCT" | "ALL") _a

set_limit: "TOP" UNSIGNED_INTEGER

// ================================= Select lists and their items
select_list: "*"
    | select_sublist ("," select_sublist)*

select_sublist: table_name "." "*"
    | derived_column

derived_column: value_expression as_clause?

// Table expressions (FROM clause: tables, join, etc.)

table_expression: from_clause (where_clause)? (group_by_clause)? (order_by_clause)? (offset_clause)?

from_clause: "FROM" from_list

from_list: table_reference ("," table_reference)*

// joining correlation_specification and as_clause

as_clause: "AS"? identifier

table_reference: joined_table
    | table_name (SPACE as_clause)?
    | subquery (SPACE  as_clause)?

// JOIN clauses and related elements

joined_table: qualified_join
    | sub_join

sub_join: "(" joined_table ")"

join_opener: sub_join
    | table_name as_clause?
    | subquery as_clause?

qualified_join: join_opener join_clause

subquery: "(" query_expression ")"

join_clause: join_method? join table_reference (join_specification)? ((sub_join | join_clause))*

join_type: ("INNER"
    | (outer_join_type)? "OUTER") _a

outer_join_type: ("LEFT" | "RIGHT" | "FULL") _a

join_method: natural? (join_type)?

join_specification: join_condition
    | named_columns_join

join_condition: on search_condition

named_columns_join: "USING" "(" identifier ("," identifier)* ")"

// WHERE clause

where_clause: where search_condition

search_condition: boolean_term (or boolean_term)*

boolean_term: boolean_factor (and boolean_factor)*

predicate: comparison_predicate
    | between_predicate
    | in_predicate
    | like_predicate
    | null_predicate
    | exists_predicate

boolean_factor: not? boolean_primary

boolean_primary: "(" search_condition ")"
    | predicate

null_predicate: column_reference "IS" not? ("TRUE" | "FALSE" | "UNKNOWN" | "NULL")

comparison_predicate: value_expression comp_op value_expression

like_predicate: character_value_expression not? ("ILIKE" | "LIKE") character_value_expression

comp_op: "=" | "<>" | "<" | ">" | "<=" | ">="

between_predicate: value_expression not? between value_expression and value_expression

in_predicate: value_expression not? in in_predicate_value

in_predicate_value: identifier
    | "(" value_expression ("," value_expression)* ")"
    | "(" query_expression ")"

exists_predicate: not? "EXISTS" subquery

order_by_clause: "ORDER" "BY" sort_specification_list

sort_specification_list: sort_specification ("," sort_specification)*

sort_specification: sort_key (ordering_specification)?

sort_key: identifier
    | UNSIGNED_INTEGER

ordering_specification: "ASC" | "DESC"

// HAVING clause depends on GROUP BY clause
group_by_clause: "GROUP" "BY" group_by_term_list (having_clause)?

group_by_term_list: identifier ("," identifier)*

having_clause: "HAVING" ("(" search_condition ")"
    | search_condition)

offset_clause: "OFFSET" UNSIGNED_INTEGER

// Identifiers (<schema>.<table>.<field>), numerical, geometrical, string expressions and functions

table_name: identifier ("." identifier)~0..2

// # we don't re-use table_name here since PEG uses greedy matching
// # and thus would parse x.a all as a table name.  Thus, for
// # column_reference we simply allow 1..4 identifiers.
column_reference: (identifier ".") ~ 0..3 identifier

identifier: (regular_identifier | delimited_identifier)

delimited_identifier: /"([^"]|\"\")*"/

regular_identifier: ((keyword)~0 /[a-zA-Z]+[a-zA-Z0-9_]*/)

character_string_literal: (/[']/ (/['']/ | /[^']/)* /[']/ (SPACE+ SQL_COMMENT)*)+

fold_function: ("UPPER" | "LOWER") "(" character_value_expression ")"

string_value_function: string_geometry_function
    | fold_function
    | user_defined_function

character_primary: character_string_literal
    | string_value_function
    | value_expression_primary

concatenation: character_primary "||" character_value_expression

geometry_function: geometry_value_function
    | non_predicate_geometry_function
    | predicate_geometry_function
    | region
    | extract_coord_sys

bitwise_op: "&" | "|" | "^"

bitwise_expression: "~" numeric_value_expression
    | numeric_value_expression bitwise_op numeric_value_expression

string_value_expression: character_value_expression

character_value_expression: concatenation
    | column_reference
    | character_primary

geometry_value_function: box
    | centroid
    | circle
    | point
    | polygon
    | region
    | user_defined_function

coordinates: numeric_value_expression "," numeric_value_expression

box: "BOX" "(" ( character_string_literal ",")? coordinates "," numeric_value_expression "," numeric_value_expression ")"

centroid: "CENTROID" "(" geometry_value_expression ")"

circle: "CIRCLE" "(" string_value_expression "," coordinates "," numeric_value_expression ")"

polygon: "POLYGON" "(" string_value_expression "," coordinates "," coordinates ("," coordinates)* ")"

non_predicate_geometry_function: area
    | coord1
    | coord2
    | distance

area: "AREA" "(" geometry_value_expression ")"

coord1: "COORD1" "(" coord_value ")"

coord2: "COORD2" "(" coord_value ")"

coord_value: point
    | column_reference

distance: "DISTANCE" "(" coord_value "," coord_value ")"

predicate_geometry_function: contains
    | intersects

contains: "CONTAINS" "(" geometry_value_expression "," geometry_value_expression ")"

intersects: "INTERSECTS" "(" geometry_value_expression "," geometry_value_expression ")"

region: "REGION" "(" string_value_expression ")"

extract_coord_sys: "COORDSYS" "(" geometry_value_expression ")"

string_geometry_function: extract_coord_sys
    | user_defined_function

math_function: (onetwo_param_math "(" numeric_value_expression ("," SIGNED_INTEGER)? ")")
    | (two_param_math "(" numeric_value_expression "," numeric_value_expression ")" )
    | (one_param_math "(" numeric_value_expression ")")
    | rand_function
    | (no_param_math "(" ")")

trig_function: (two_param_trig "(" numeric_value_expression "," numeric_value_expression ")")
    | (one_param_trig "(" numeric_value_expression ")")

// No Params
no_param_math: "PI"

// One Param
one_param_trig: "ACOS"
    | "ASIN"
    | "ATAN"
    | "COS"
    | "COT"
    | "SIN"
    | "TAN"

one_param_math: "ABS"
    | "CEILING"
    | "DEGREES"
    | "EXP"
    | "FLOOR"
    | "LOG10"
    | "LOG"
    | "RADIANS"
    | "SQRT"

// Two Params
two_param_math: "MOD" | "POWER"

two_param_trig: "ATAN2"

onetwo_param_math: "ROUND" | "TRUNCATE"

rand_function: "RAND" "(" (numeric_value_expression)? ")"

string_function: string_func_name "(" value_expression ")"

string_func_name: "LOWER"

set_function_specification: "COUNT" "(" ("*" | (set_quantifier)? identifier) ")"
    | general_set_function

set_function_type: "AVG" | "MAX" | "MIN" | "SUM"

general_set_function: set_function_type "(" set_quantifier? numeric_value_expression ")"

point: "POINT" "(" ( string_value_expression | "NULL") "," coordinates ")"

numeric_value_expression: term (("+" | "-") numeric_value_expression)*

term: factor (("*" | "/") term)*

factor: ("-" | "+")? numeric_primary

numeric_value_function: math_function
    | trig_function
    | numeric_geometry_function
    | user_defined_function

numeric_geometry_function: predicate_geometry_function
    | non_predicate_geometry_function

udf_name: udf_prefix regular_identifier

user_defined_function: udf_name "(" (value_expression ("," value_expression)*)? ")"

// We need to seriously re-write value_expression because PEG
// doesn't have an actual longest-match operator.  Thus, we
// cannot decide on the type of the first operand.
// TODO: see how much this overproduces wrt the original grammar:
// (e.g., is '5'+4+3 ok by the BNF?  PG accepts that, btw)

value_expression_first_operand: user_defined_function
	| column_reference
	| string_expression_operand
	| numeric_expression_operand

value_expression: (value_expression_first_operand ( string_expression_rest | numeric_expression_rest)? | geometry_value_expression)

// TODO: value_expression_primary (as in the BNF) is unnecessarily wide
// here ("CENTROID(3)")
geometry_value_expression: value_expression_primary
    | geometry_value_function

value_expression_primary: unsigned_literal
    | column_reference
    | set_function_specification
    | "(" value_expression ")"

string_expression: string_expression_operand (string_expression_rest)*

string_expression_operand: character_value_expression

string_expression_rest: "||" string_expression_operand

numeric_expression: numeric_expression_operand (numeric_expression_rest)*

numeric_expression_operand: numeric_value_expression

numeric_expression_rest: ("+" | "-" | "*" | "/") numeric_expression_operand

approximate_numeric_literal: exact_numeric_literal "E" SIGNED_INTEGER

exact_numeric_literal: (UNSIGNED_INTEGER ".")* UNSIGNED_INTEGER

// TODO: We should take out character_string_literal here, MD thinks --
// what sort of use case did people have in mind here?
// "POINT('ICRS',X,'SY')"

unsigned_literal: unsigned_numeric_literal
    | character_string_literal

unsigned_numeric_literal: approximate_numeric_literal
    | exact_numeric_literal

numeric_primary: value_expression_primary
    | numeric_value_function

unsigned_hexadecimal: "0x" HEXDIGIT+

// Reserved words

as: "AS" _a

on: "ON" _a

in: "IN" _a

join: "JOIN" _a

natural: "NATURAL" _a

between: "BETWEEN" _a

and: "AND" _a

or: "OR" _a

not: "NOT" _a

where: "WHERE" _a

keyword: adql_reserved_word | sql_reserved_word

adql_reserved_word: ("ABS" | "ACOS" | "AREA" | "ASIN" | "ATAN2" | "ATAN"
    | "BIT_AND" | "BIT_NOT" | "BIT_OR" | "BIT_XOR" | "BOX"
    | "CEILING" | "CENTROID" | "CIRCLE" | "CONTAINS" | "COORD1"
    | "COORD2" | "COORDSYS" | "COS" | "DEGREES" | "DISTANCE"
    | "EXP" | "FLOOR" | "ILIKE" | "INTERSECTS" | "IN_UNIT" | "LOG10"
    | "LOG" | "MOD" | "PI" | "POINT" | "POLYGON" | "POWER" | "RADIANS"
    | "REGION" | "RAND" | "ROUND" | "SIN" | "SQRT" | "TOP" | "TAN"
    | "TRUNCATE")

sql_reserved_word: ("ABSOLUTE"
| "ACTION"
| "ADD"
| "ALLOCATE"
| "ALL"
| "ALTER"
| and
| "ANY"
| "ARE"
| as
| "ASC"
| "ASSERTION"
| "AT"
| "AUTHORISATION"
| "AVG"
| "BEGIN"
| between
| "BIT_LENGTH"
| "BIT"
| "BOTH"
| "BY"
| "CASCADE"
| "CASCADED"
| "CASE"
| "CAST"
| "CATALOG"
| "CHARACTER"
| "CHAR_LENGTH"
| "CHAR"
| "CHARACTER_LENGTH"
| "CHECK"
| "CLOSE"
| "COALESCE"
| "COLLATE"
| "COLLATION"
| "COLUMN"
| "COMMIT"
| "CONNECT"
| "CONNECTION"
| "CONSTRAINT"
| "CONSTRAINTS"
| "CONTINUE"
| "CONVERT"
| "CORRESPONDING"
| "COUNT"
| "CREATE"
| "CROSS"
| "CURRENT_DATE"
| "CURRENT_TIME"
| "CURRENT_TIMESTAMP"
| "CURRENT_USER"
| "CURRENT"
| "CURSOR"
| "DATE"
| "DAY"
| "DEALLOCATE"
| "DECIMAL"
| "DECLARE"
| "DEFAULT"
| "DEFERRABLE"
| "DEFERRED"
| "DELETE"
| "DESCRIBE"
| "DESCRIPTOR"
| "DESC"
| "DIAGNOSTICS"
| "DISCONNECT"
| "DISTINCT"
| "DOMAIN"
| "DOUBLE"
| "DROP"
| "ELSE"
| "'ENDEXEC"
| "END"
| "ESCAPE"
| "EXCEPT"
| "EXCEPTION"
| "EXECUTE"
| "EXEC"
| "EXISTS"
| "EXTERNAL"
| "EXTRACT"
| "FALSE"
| "FETCH"
| "FIRST"
| "FLOAT"
| "FOR"
| "FOREIGN"
| "FOUND"
| "FROM"
| "FULL"
| "GET"
| "GLOBAL"
| "GOTO"
| "GO"
| "GRANT"
| "GROUP"
| "HAVING"
| "HOUR"
| "IDENTITY"
| "IMMEDIATE"
| "INDICATOR"
| "INITIALLY"
| "INNER"
| "INPUT"
| "INSENSITIVE"
| "INSERT"
| "INTEGER"
| "INTERSECT"
| "INTERVAL"
| "INTO"
| "INT"
| "IN"
| "IS"
| "ISOLATION"
| join
| "KEY"
| "LANGUAGE"
| "LAST"
| "LEADING"
| "LEFT"
| "LEVEL"
| "LIKE"
| "ILIKE"
| "LOCAL"
| "LOWER"
| "MATCH"
| "MAX"
| "MIN"
| "MINUTE"
| "MODULE"
| "MONTH"
| "NAMES"
| "NATIONAL"
| natural
| "NCHAR"
| "NEXT"
| "NO"
| not
| "NULL"
| "NULLIF"
| "NUMERIC"
| "OCTET_LENGTH"
| "OFFSET"
| "OF"
| on
| "ONLY"
| "OPEN"
| "OPTION"
| or
| "ORDER"
| "OUTER"
| "OUTPUT"
| "OVERLAPS"
| "PAD"
| "PARTIAL"
| "POSITION"
| "PRECISION"
| "PREPARE"
| "PRESERVE"
| "PRIMARY"
| "PRIOR"
| "PRIVILEGES"
| "PROCEDURE"
| "PUBLIC"
| "READ"
| "REAL"
| "REFERENCES"
| "RELATIVE"
| "RESTRICT"
| "REVOKE"
| "RIGHT"
| "ROLLBACK"
| "ROWS"
| "SCHEMA"
| "SCROLL"
| "SECOND"
| "SELECT"
| "SECTION"
| "SESSION_USER"
| "SET"
| "SIZE"
| "SMALLINT"
| "SOME"
| "SPACE"
| "SQL"
| "SQLCODE"
| "SQLERROR"
| "SQLSTATE"
| "SUBSTRING"
| "SUM"
| "SYSTEM_USER"
| "TABLE"
| "TEMPORARY"
| "THEN"
| "TIMESTAMP"
| "TIMEZONE_HOUR"
| "TIMEZONE_MINUTE"
| "TIME"
| "TO"
| "TRAILING"
| "TRANSACTION"
| "TRANSLATE"
| "TRANSLATION"
| "TRIM"
| "TRUE"
| "UNION"
| "UNIQUE"
| "UNKNOWN"
| "UPDATE"
| "UPPER"
| "USAGE"
| "USER"
| "USING"
| "VALUES"
| "VALUE"
| "VARCHAR"
| "VARYING"
| "VIEW"
| "WHENEVER"
| "WHEN"
| where
| "WITH"
| "WORK"
| "WRITE"
| "YEAR"
| "ZONE" )

_a: /[^A-Z0-9_]/

udf_prefix: "ivo_"

%import common.LETTER
%import common.DIGIT
%import common.LCASE_LETTER -> SIMPLE_LATIN_LOWER_CASE_LETTER
%import common.UCASE_LETTER -> SIMPLE_LATIN_UPPER_CASE_LETTER
%import common.INT -> UNSIGNED_INTEGER
%import common.SIGNED_INT -> SIGNED_INTEGER
%import common.NEWLINE
%import common.HEXDIGIT
%import common.SQL_COMMENT
%import common.WS_INLINE -> SPACE
%import common.NEWLINE

%ignore SPACE